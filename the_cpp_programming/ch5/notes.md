## 5.1
一些指针的例子;
* int* pi;
* char** ppc; 指向指向一个字符的指针的指针;
* int* ap[15]; 15个指向int的指针;
* int (\*fp)(\*char); 到函数的指针;
* int\* f(char\*);

*由于许多机器最细只能取出字节，故一个bool量最少也要占据1byte的空间；->想更紧凑：按位逻辑操作或使用结构体中的位域*

## 5.2
int vl[i]; 错

vector<int> ve(i); 对

### 5.2.2
字符串文字量："this is a string"，末尾多一个'\n'，类型为“适当个数的const字符的数组”

可以用字符串文字给char*赋值，但不可以通过该指针对字符串文字进行修改（char*只是一个指针而已，实际存储字符串文字时是不可修改的）;

通过：

char p[] = "lala";
p[0] = 'R';

是可以修改的。

*字符串常量是静态分配的，所以让函数返回他们是科学的*

带有前缀L的字符串是宽字符的字符串。类型为const wchar_t[]

## 5.4
const 常量；

1. 维持某些值不会再变;
2. 控制指针不要被写;
3. 函数参数往往只读不写；

### 5.4.1
const \*p， const使p所指向的对象成为常量;

而 \*const \*p 才使p固定指向某处；

可以将一个变量的地址赋给一个指向常量的指针，以避免某个范围内对该变量的修改（函数参数）

但不可把一个常量的地址赋给一个指向变量的指针;

## 5.4
引用（别名），需要初始化;

int i;
int& r = i;

通过r访问的都是i;其实没办法再改变r了，因为对r做的所有操作都会被当作是在i上做的。

没有const修饰时，引用的类型必须与所引用对象的类型相同。

有const修饰时：have fun:

1. 对左值进行隐式类型转换
2. 将转换结果存入一个相应类型的*临时变量*中
3. 将该临时变量作为初始式的值

*一般，尽量避免函数对参数进行修改——应当返回一个新值，或者明确地要求一个指针参数*

例子：

void increment (int& aa) {aa++;} ： 不好，没有给出会对x进行修改的明确提示;

int increment (int a) {return a++;}

void increment (int* a) {(\*p)++;}
